# ADR.002 Выбор шаблона интеграции
<!-- Название ADR состоит из [ADR.###] [Коротко суть принятого решения] -->

* Статус: Предложено
* Владелец: 

## Контекст
<!-- Описание проблемы, требующей решения, причин, побудивших принять решение, ограничений, действовавших на момент принятия решения -->
Необходимо выбрать шаблон интеграции для проектируемой платформы конференций helloconf.mts.ru. Особенностями разрабатываемой платформы являются:
* большое количество пользователей (как спикеров, так и слушателей),
* известен перечень реализуемых объектов, а также фукнционал платформы,
* необходимо масштабируемое решение.

## Выбор интеграционного решения
<!-- Описание рассмотренных вариантов c их плюсами и минусами -->

### По паттерну интеграции
#### Датацентричный паттерн
* **Плюсы**
  * Позволяет интегрировать разные сервисы с различными форматами данных
* **Минусы**
  * Требует большого количества данных в различных форматах

#### Объектно-центричный паттерн
* **Плюсы**
  * Позволяет объединять данные в объекты, которые могут быть использованы в различных сервисах
  * Удобный вариант взаимодействия с данными
* **Минусы**
  * Предполагает использования объекто-ориентированного подхода при разработке

#### Функционально-центричный паттерн
* **Плюсы**
  * Позволяет интегрировать функции, без необходимости интеграции всего приложения
  * Обеспечивает более наиболее гибкую интеграцию приложений
* **Минусы**
  * Предполагает большое количество различных функций для интеграции
  * Сложность в разработке и поддержке

### По структуре
#### Точка-точка
* **Плюсы**
  * Наиболее быстрый и простой вариант взаимодействия
* **Минусы**
  * Отсутствие гибкости при использовании различных форматов данных и протоколов взаимодействия
  * Большие сложности при масштабировании

#### Звезда
* **Плюсы**
  * Позволяет унифицировать взаимодействие по различным протоколам и форматам данных
  * Простота и удобство горизонтального масштабирования
* **Минусы**
  * При отсутствии резервирования - наличие единой точки отказа

### По связанности
#### Синхронное взаимодействие
* **Плюсы**
  * Более простая реализация
  * Простое управление и контроль потока данных
* **Минусы**
  * Зависимость от скорости обработки запросов на другой стороне
  * Неэффективное использование ресурсов при необходимости ожидания ответа

#### Асинхронное взаимодействие
* **Плюсы**
  * Отсутствие зависимости от скорости обработки запросов на другой стороне
  * Более эффективное использование ресурсов в случае, когда необходимо ожидать ответ
* **Минусы**
  * Более сложная реализация

### Сравнение способов/протоколов взаимодействия
* **Производительность**
  * REST: Средняя производительность из-за использования HTTP протокола и текстовых форматов данных, таких как JSON или XML.
  * gRPC: Высокая производительность благодаря использованию протокола Protobuf и бинарных форматов данных.
  * GraphQL: Средняя производительность из-за использования HTTP протокола, но с возможностью выборочного запроса только необходимых данных.

* **Масштабируемость**
  * REST: Хорошая масштабируемость благодаря кешированию и stateless подхода.
  * gRPC: Отличная масштабируемость благодаря использованию протокола HTTP/2 и механизма стриминга.
  * GraphQL: Хорошая масштабируемость благодаря использованию HTTP протокола и возможности выборочного запроса только необходимых данных.

* **Простота реализации**
  * REST: Простая реализация и понимание благодаря использованию стандартных HTTP методов и семантики.
  * gRPC: Сложная реализация и понимание из-за использования бинарных форматов данных и необходимости генерации кода.
  * GraphQL: Средняя сложность реализации и понимания благодаря использованию текстовых форматов данных и возможности выборочного запроса только необходимых данных.

* **Скорость развертывания**
   * REST: Один из самых простых в реализации и развертывании способов взаимодействия. REST API может быть развернут на любом веб-сервере с поддержкой HTTP протокола, что делает его быстрым и простым в развертывании.
   * gRPC: Реализация и развертывание gRPC может занимать больше времени, чем у REST, из-за необходимости генерации кода и настройки транспортных протоколов.
   * GraphQL: Реализация и развертывание GraphQL может занимать больше времени, чем у REST, из-за необходимости настройки схемы GraphQL и понимания ее работ.

* **Поддержка**
  * REST: Широко распространен и поддерживается многими языками программирования и фреймворками.
  * gRPC: Поддерживается многими языками программирования, но не так широко распространен, как REST.
  * GraphQL: Активно поддерживается, но гораздо менее распространен.

| Критерий | REST API | gRPC | GraphQL |
|:---------|:--------:|:----:|:-------:|
| Производительность | 3 | 5 | 3 |
| Масштарибуемость | 4 | 5 | 4 |
| Простота реализции | 4 | 2 | 3 |
| Скорость развертывания | 5 | 3 | 3 |
| Поддержка | 5 | 4 | 3 |
| **Общая оценка** | 4,2 | 3,8 | 3,2 |

### Выбор паттерна взаимодействия между микросервисами
* **Скорость обработки запроса**
  * Синхронное: Может приводить к блокировкам и задержкам при обработке запросов, особенно при большом их количестве
  * Асинхронное: Высокая скорость обработки запросов, т.к. не требует блокировки и ожидания ответа на запрос
* **Надежность**
  * Синхронное: Может быть менее надежным, так как ошибки в одном сервисе могут повлиять на другие сервисы, вызывая каскадные сбои
  * Асинхронное: Обеспечивает более высокую надежность, так как ошибки в одном сервисе не приводят к каскадным сбоям в других сервисах
* **Простота реализации**
  * Синхронное: Простое в реализации, так как не требует использования дополнительных инструментов и технологий для обработки сообщений между сервисами
  * Асинхронное: Является более сложным в реализации, так как требует использования дополнительных инструментов и технологий, таких как очереди либо брокеры сообщений
* **Масштабируемость**
  * Синхронное: Может быть менее масштабируемым, так как требует обработки запросов в реальном времени и может приводить к перегрузке системы
  * Асинхронное: лучше масштабируется ввиду взаимодействия через очередь или брокер сообщений и использования механизмов отложенной обработки запросов и управления нагрузкой
* **Простота отладки и тестирования**
  * Синхронное: Может быть достаточно сложным для отладки и тестирования, так как ошибки могут быть связаны с различными сервисами, что затруднит локализацию и устранение проблем
  * Асинхронное: Также является сложным для отладки и тестирования, т.к. требует работу с очередями сообщений

| Критерий | Синхронное | Асинхронное |
|:---------|:----------:|:-----------:|
| Скорость | 2 | 4 |
| Надежность | 3 | 5 |
| Простота реализции | 4 | 3 |
| Масштабируемость | 3 | 5 |
| Отладка и тестирование | 3 | 3 |
| **Общая оценка** | 3,0 | 4,0 |

## Решение
<!-- Описание выбранного решения. Решение должно быть сформулировано чётко ("Мы используем...", "Мы не используем", а не "Желательно.." или "Предлагается..."). 
Должна быть понятна связь между решением и проблемой, почему выбрали именно это решение из вариантов -->
Ключевыми критериями при выборе архитектурных паттернов интеграции являются:
* Быстродействие
* Простота и скорость развертывания
* Возможность масштабирования
* Возможность реализации асинхронного взаимодействия
* Распространенность подхода

Таким образом, принимается решение об использовании следующих паттернов:
* Объектно-центричный паттерн
* Структура интеграции: звезда, используя очередь сообщений
* Асинхронные сообщения
* REST API для обращения к сервисам и асинхронное взаимодействие между микросервисами

## Последствия
<!-- Положительные и отрицательные последствия (trade-offs). Арх. решения, которые потребуется принять как следствие принятого решения. Если решение содержит риски, то описано, как с ними планируют поступить (за счет чего снижать, почему принять). -->
Описанные решения позволяют выполнить все представленные требования в полном объеме, обеспечив баланс между быстродействием, простотой реализации и возможностью масштабирования
